package main

import (
  "fmt"
  "html/template"
  "log"
  "net/http"
  "sync"
  "io"
  "encoding/json"
  // "net/http/httputil"
  // "strings"
)

var word string
var wordMutex sync.RWMutex

var longPollChannels []chan string
var longPollChannelsMutex sync.RWMutex

func rootHandler(w http.ResponseWriter, r *http.Request) {
  switch r.Method {
    case http.MethodGet:
      t, _ := template.ParseFiles("form.tmpl")
      t.Execute(w, nil)
    default:
      http.Error(w, "", http.StatusMethodNotAllowed)
  }
}

func wordHandler(w http.ResponseWriter, r *http.Request) {
  switch r.Method {
    case http.MethodGet:
      wordMutex.RLock()

      fmt.Fprint(w, word)

      wordMutex.RUnlock()
    case http.MethodPost:
      r.ParseForm()

      wordMutex.Lock() // -Begin critical section-------------------------------
      longPollChannelsMutex.Lock()

      word = r.FormValue("prefix") + word + r.FormValue("suffix")
      fmt.Printf("new word: '%s'\n", word)
      fmt.Fprint(w, word)
      // broadcast new word to all long poll listeners
      for _, c := range longPollChannels {
        c <- word
      }
      longPollChannels = make([]chan string, 0) // clear

      wordMutex.Unlock() // -End critical section-------------------------------
      longPollChannelsMutex.Unlock()
    default:
      http.Error(w, "", http.StatusMethodNotAllowed)
  }
}

func nextWordHandler(w http.ResponseWriter, r *http.Request) {
  switch r.Method {
    case http.MethodGet:
      longPollChannelsMutex.Lock()

      myChan := make(chan string)
      longPollChannels = append(longPollChannels, myChan)

      longPollChannelsMutex.Unlock()

      fmt.Fprint(w, <-myChan)
    default:
      http.Error(w, "", http.StatusMethodNotAllowed)
  }
}

// Generated by https://mholt.github.io/json-to-go/
type Entry []struct {
	Word      string `json:"word"`
	Phonetic  string `json:"phonetic,omitempty"`
	Phonetics []struct {
		Text      string `json:"text"`
		Audio     string `json:"audio"`
		SourceURL string `json:"sourceUrl,omitempty"`
	} `json:"phonetics"`
	Meanings []struct {
		PartOfSpeech string `json:"partOfSpeech"`
		Definitions  []struct {
			Definition string        `json:"definition"`
			Synonyms   []string `json:"synonyms"`
			Antonyms   []string `json:"antonyms"`
		} `json:"definitions"`
		Synonyms []string `json:"synonyms"`
		Antonyms []string `json:"antonyms"`
	} `json:"meanings"`
	License struct {
		Name string `json:"name"`
		URL  string `json:"url"`
	} `json:"license"`
	SourceUrls []string `json:"sourceUrls"`
}
func isWordHandler(w http.ResponseWriter, r *http.Request) {
  switch r.Method {
    case http.MethodGet:
      wordMutex.RLock()

      reqUri := "https://api.dictionaryapi.dev/api/v2/entries/en/" + word
      resp, err := http.Get(reqUri)
      if err != nil {
        // handle error
      }
      defer resp.Body.Close()
      // just looking at the header works for a boolean response
      fmt.Fprint(w, resp.StatusCode == http.StatusOK)

      // Below is how you actually parse the body -- not strictly necessary for
      // simple validation, however! Would be nice to show player definitions
      // realistically.
      body, err := io.ReadAll(resp.Body)
      if err != nil {
        // handle error
      }
			var e Entry
      err = json.Unmarshal(body, &e)
			if err != nil {
        // Handle err
			}

      wordMutex.RUnlock()
    default:
      http.Error(w, "", http.StatusMethodNotAllowed)
  }
}

func main() {
  longPollChannels = make([]chan string, 0)

  http.HandleFunc("/", rootHandler) // setting router rule
  http.HandleFunc("/word", wordHandler)
  http.HandleFunc("/next-word", nextWordHandler)
  http.HandleFunc("/is-word", isWordHandler)

  err := http.ListenAndServe(":9090", nil) // setting listening port
  if err != nil {
    log.Fatal("ListenAndServe: ", err)
  }
}

