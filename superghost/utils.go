package superghost

import(
  "crypto/rand"
  "encoding/base64"
  "encoding/base32"
  "net/http"
  "regexp"
  "time"
  "fmt"
)

var _usernamePattern *regexp.Regexp
var _alphaPattern *regexp.Regexp

func validateWord(word string, usedWords map[string]bool, allowRepeats bool) (
    isWord bool, err error) {
  if !_alphaPattern.MatchString(word) {
    return false, fmt.Errorf("word is invalid format")
  }
  if _, ok := usedWords[word]; !allowRepeats && ok {
    return false, fmt.Errorf("word has already been used")
  }
  // https://github.com/ngocsangyem/freedictionaryapi
  url := "https://wordsapiv1.p.rapidapi.com/words/" + word
  req, _ := http.NewRequest("GET", url, nil)
  req.Header.Add("X-RapidAPI-Key",
                 "9015d265cemsh86b2210b6f9bf77p125fb9jsne9f77737245d")
  req.Header.Add("X-RapidAPI-Host", "wordsapiv1.p.rapidapi.com")
  // Execute the request
  res, err := http.DefaultClient.Do(req)
  if err != nil {
    return false, err
  }
  return res.StatusCode == http.StatusOK, nil
}

func newCookie(path string, username string) *http.Cookie {
  c := new(http.Cookie)
  c.Name = username
  c.Value = GetRandBase64String(32)
  c.Expires = time.Now().Add(24 * time.Hour)
  c.Path = path
  return c
}

func GetRandBase64String(length int) string {
  randomBytes := make([]byte, length)
  _, err := rand.Read(randomBytes)
  if err != nil {
    panic(err)
  }
  return base64.StdEncoding.EncodeToString(randomBytes)[:length]
}

func GetRandBase32String(length int) string {
  randomBytes := make([]byte, length)
  _, err := rand.Read(randomBytes)
  if err != nil {
    panic(err)
  }
  return base32.StdEncoding.EncodeToString(randomBytes)[:length]
}

func init() {
  _usernamePattern = regexp.MustCompile("^[[:alnum:]]+$")
  _alphaPattern = regexp.MustCompile("^[[:alpha:]]+$")
}

// Generated by https://mholt.github.io/json-to-go/
// type Entry []struct {
// 	Word      string `json:"word"`
// 	Phonetic  string `json:"phonetic,omitempty"`
// 	Phonetics []struct {
// 		Text      string `json:"text"`
// 		Audio     string `json:"audio"`
// 		SourceURL string `json:"sourceUrl,omitempty"`
// 	} `json:"phonetics"`
// 	Meanings []struct {
// 		PartOfSpeech string `json:"partOfSpeech"`
// 		Definitions  []struct {
// 			Definition string        `json:"definition"`
// 			Synonyms   []string `json:"synonyms"`
// 			Antonyms   []string `json:"antonyms"`
// 		} `json:"definitions"`
// 		Synonyms []string `json:"synonyms"`
// 		Antonyms []string `json:"antonyms"`
// 	} `json:"meanings"`
// 	License struct {
// 		Name string `json:"name"`
// 		URL  string `json:"url"`
// 	} `json:"license"`
//	SourceUrls []string `json:"sourceUrls"`
// }
